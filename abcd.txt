#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// This array defines all the JSON keys that are expected to contain date strings
// with hyphens (e.g., "2024-01-01") that we want to clean to "20240101".
const char *dateKeys[] = {
    "OpenDate",
    "ReceivedMerchantDate",
    "MerchantShipDate",
    "CardHolderDate"
};

// Number of keys in the array (used in the loop below)
const int numKeys = sizeof(dateKeys) / sizeof(dateKeys[0]);

// This function receives a JSON string (inputJson), scans it for specific date fields,
// and returns a new JSON string with hyphens removed from those date values.
char *removeHyphensFromDates(const char *inputJson) {
    if (!inputJson) return NULL; // sanity check for null input

    size_t inputLen = strlen(inputJson); // get the input length
    // Allocate memory for the output string. We are only removing characters,
    // so the output will never be longer than the input.
    char *outputJson = (char *)malloc(inputLen + 1); // +1 for null-terminator
    if (!outputJson) return NULL; // check for malloc failure

    const char *src = inputJson;   // Pointer to read from input
    char *dst = outputJson;        // Pointer to write to output

    // Loop through the entire input string character by character
    while (*src) {
        // We're only interested in JSON keys, which begin with a double-quote
        if (*src == '"') {
            int matchedKeyIndex = -1; // Track whether we match one of our target date keys

            // Loop through each date key and compare it to the current position
            for (int i = 0; i < numKeys; i++) {
                size_t keyLen = strlen(dateKeys[i]);

                // We're checking for the exact pattern: "KEY":" â€” i.e., a quote,
                // followed by the key name, followed by '":"'.
                // NOTE: if your JSON formatting uses `"KEY" : "value"` (with spaces),
                // you may need to update this logic to skip whitespace.
                if (strncmp(src + 1, dateKeys[i], keyLen) == 0 &&
                    strncmp(src + 1 + keyLen, "\":\"", 3) == 0) {
                    matchedKeyIndex = i;
                    break; // no need to check further once matched
                }
            }

            // If a date key was matched (like "OpenDate")
            if (matchedKeyIndex != -1) {
                size_t keyLen = strlen(dateKeys[matchedKeyIndex]);

                // Copy the key + colon + quote to output exactly as-is
                // This is the string: "KEY":"
                strncpy(dst, src, keyLen + 4);
                dst += keyLen + 4;
                src += keyLen + 4;

                // Now, we are inside the value (like "2024-01-01")
                // Copy character by character, but skip hyphens
                while (*src && *src != '"') { // Stop when we reach the closing quote
                    if (*src != '-') {
                        *dst++ = *src; // Copy everything except '-'
                    }
                    src++;
                }

                // After value ends (at closing quote), copy the quote too
                if (*src == '"') {
                    *dst++ = *src++;
                }

                continue; // Go back to the main loop
            }
        }

        // If it's not one of the target date fields, just copy the character as-is
        *dst++ = *src++;
    }

    *dst = '\0'; // Null-terminate the output string
    return outputJson; // Return the cleaned-up JSON
}



-==============


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// List of date keys to search in the JSON
const char *dateKeys[] = {
    "OpenDate",
    "ReceivedMerchantDate",
    "MerchantShipDate",
    "CardHolderDate"
};
const int numKeys = sizeof(dateKeys) / sizeof(dateKeys[0]);

char *removeHyphensFromDates(const char *inputJson) {
    if (!inputJson) return NULL;

    size_t inputLen = strlen(inputJson);
    // Allocate output buffer - input length + 1 is enough since we only remove chars
    char *outputJson = (char *)malloc(inputLen + 1);
    if (!outputJson) return NULL;

    const char *src = inputJson;   // input pointer
    char *dst = outputJson;        // output pointer

    while (*src) {
        // Check if current char is a quote, signaling possible start of a key
        if (*src == '"') {
            int matchedKeyIndex = -1;
            // Check all date keys
            for (int i = 0; i < numKeys; i++) {
                size_t keyLen = strlen(dateKeys[i]);
                // Check if substring after quote matches key, and next chars are '": "'
                if (strncmp(src + 1, dateKeys[i], keyLen) == 0 &&
                    strncmp(src + 1 + keyLen, "\":\"", 3) == 0) {
                    matchedKeyIndex = i;
                    break;
                }
            }

            if (matchedKeyIndex != -1) {
                // Copy the key and '":"'
                size_t keyLen = strlen(dateKeys[matchedKeyIndex]);
                strncpy(dst, src, keyLen + 4); // quote + key + '":"'
                dst += keyLen + 4;
                src += keyLen + 4;

                // Now remove hyphens inside the date value until closing quote
                while (*src && *src != '"') {
                    if (*src != '-') {
                        *dst++ = *src; // copy non-hyphen characters
                    }
                    src++;
                }
                // Copy the closing quote
                if (*src == '"') {
                    *dst++ = *src++;
                }
                continue; // continue main loop
            }
        }
        // Default: copy current char
        *dst++ = *src++;
    }

    *dst = '\0'; // null-terminate output string
    return outputJson;
}




int main() {
    const char *jsonInput = "{\"AcctDetails\":{\"AcctBalance\":\"100\",\"TrxList\":[{\"ARN\":\"2001\",\"OpenDate\":\"2024-01-01\",\"DisputeIntent\":{\"ReceivedMerchantDate\":\"2025-12-10\",\"MerchantShipDate\":\"2025-12-11\"}},{\"ARN\":\"2002\",\"OpenDate\":\"2020-10-01\",\"DisputeIntent\":{\"ReceivedMerchantDate\":\"2023-05-10\",\"MerchantShipDate\":\"2023-05-11\",\"CardHolderDate\":\"2023-05-12\"}}]}}";

    char *cleanJson = removeHyphensFromDates(jsonInput);
    if (cleanJson) {
        printf("Cleaned JSON:\n%s\n", cleanJson);
        free(cleanJson);
    } else {
        printf("Error processing JSON.\n");
    }

    return 0;
}



// Assume this is already correlated using web_reg_save_param_json
web_reg_save_param("response_json",
    "LB=",
    "RB=",
    "Search=Body",
    LAST);

// After web request
web_url("GetDisputeData", ...);

// Evaluate JSON and clean it
const char *jsonInput = lr_eval_string("{response_json}");
char *cleanedJson = removeHyphensFromDates(jsonInput);

if (cleanedJson) {
    // Use cleanedJson in next request
    lr_save_string(cleanedJson, "cleaned_json");

    // Example use in next request
    web_custom_request("PostCleaned",
        "Body={cleaned_json}",
        ...
        LAST);

    free(cleanedJson);
} else {
    lr_error_message("Failed to clean JSON");
}



Sub CleanAndRunAll()
    Dim ws As Worksheet
    Dim keepSheetName As String
    Dim shName As String
    Dim i As Long
    
    keepSheetName = "data"
    
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    ' Delete all sheets except the one named "data"
    For i = ThisWorkbook.Worksheets.count To 1 Step -1
        Set ws = ThisWorkbook.Worksheets(i)
        shName = LCase(ws.Name)
        If shName <> LCase(keepSheetName) Then
            ws.Delete
        End If
    Next i
    
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    
    ' Call your macros in order
    Call SummarizeTransactions
    Call ExpandLargeTransactions
    Call CreateTransposedSheets
    
    MsgBox "All done! Sheets cleaned and macros executed.", vbInformation
End Sub

Sub SummarizeTransactions()
    Dim wsData As Worksheet, wsOut As Worksheet
    Dim dict As Object, key As Variant
    Dim i As Long, lastRow As Long
    Dim acct As String, card As String
    Dim trxDate As String, trxAmt As Double
    Dim tempArray As Variant
    Dim parts As Variant

    ' Set worksheets
    Set wsData = Worksheets("Data") ' Adjust if needed
    Set wsOut = Worksheets.Add
    wsOut.Name = "Summary"

    Set dict = CreateObject("Scripting.Dictionary")

    lastRow = wsData.Cells(wsData.Rows.count, 1).End(xlUp).Row

    ' Build dictionary
    For i = 2 To lastRow
        acct = wsData.Cells(i, 2).Value
        card = wsData.Cells(i, 3).Value
        trxDate = wsData.Cells(i, 4).Text
        trxAmt = wsData.Cells(i, 5).Value
        key = acct & "|" & card

        If Not dict.exists(key) Then
            dict(key) = Array("", "", 0)
        End If

        tempArray = dict(key)
        tempArray(0) = tempArray(0) & trxDate & ", "
        tempArray(1) = tempArray(1) & trxAmt & ", "
        tempArray(2) = tempArray(2) + 1
        dict(key) = tempArray
    Next i

    ' Write headers
    With wsOut
        .Cells(1, 1).Value = "acctnumber"
        .Cells(1, 2).Value = "cardnumber"
        .Cells(1, 3).Value = "trxdates"
        .Cells(1, 4).Value = "trxamts"
        .Cells(1, 5).Value = "count_trxdates"
        
        .Columns("A:D").NumberFormat = "@" ' Format dates and amounts as text
    End With

    ' Output results
    i = 2
    For Each key In dict.Keys
        parts = Split(key, "|")
        tempArray = dict(key)

        wsOut.Cells(i, 1).Value = parts(0)
        wsOut.Cells(i, 2).Value = parts(1)
        wsOut.Cells(i, 3).Value = Left(tempArray(0), Len(tempArray(0)) - 2)
        wsOut.Cells(i, 4).Value = Left(tempArray(1), Len(tempArray(1)) - 2)
        wsOut.Cells(i, 5).Value = tempArray(2)
        i = i + 1
    Next key
End Sub


Sub ExpandLargeTransactions()
    Dim wsSrc As Worksheet, wsOut As Worksheet
    Dim lastRow As Long, i As Long, outputRow As Long
    Dim maxTrx As Long: maxTrx = 5 ' Configurable max transactions per row
    Dim sliceSizes As Variant: sliceSizes = Array(2, 4, 5, 10)
    Dim datesArr As Variant, amtsArr As Variant
    Dim numTrx As Long, j As Long, setNum As Long
    Dim shuffledPairs As Variant
    Dim numSets As Long: numSets = 2 ' Number of slice sets to generate per row

    Set wsSrc = Worksheets("Summary")
    Set wsOut = Worksheets.Add
    wsOut.Name = "Expanded"

    ' Output headers
    With wsOut
        .Cells(1, 1).Value = "acctnumber"
        .Cells(1, 2).Value = "cardnumber"
        .Cells(1, 3).Value = "trxdates"
        .Cells(1, 4).Value = "trxamts"
        .Cells(1, 5).Value = "count_trxdates"
        .Cells(1, 6).Value = "set_number" ' New column to track which set
    End With
    outputRow = 2

    lastRow = wsSrc.Cells(wsSrc.Rows.count, 1).End(xlUp).Row

    Randomize ' Initialize random number generator once

    For i = 2 To lastRow
        numTrx = wsSrc.Cells(i, 5).Value
        datesArr = Split(wsSrc.Cells(i, 3).Value, ",")
        amtsArr = Split(wsSrc.Cells(i, 4).Value, ",")

        If numTrx <= maxTrx Then
            ' Just generate numSets copies of whole shuffled sets
            For setNum = 1 To numSets
                shuffledPairs = PairAndShuffle(datesArr, amtsArr)
                
                wsOut.Cells(outputRow, 1).Value = wsSrc.Cells(i, 1).Value
                wsOut.Cells(outputRow, 2).Value = wsSrc.Cells(i, 2).Value
                wsOut.Cells(outputRow, 3).Value = Join(SliceArray(shuffledPairs, numTrx, 0), ", ")
                wsOut.Cells(outputRow, 4).Value = Join(SliceArray(shuffledPairs, numTrx, 1), ", ")
                wsOut.Cells(outputRow, 5).Value = numTrx
                wsOut.Cells(outputRow, 6).Value = setNum
                outputRow = outputRow + 1
            Next setNum
        Else
            ' For each set, generate all slices with independent shuffles
            For setNum = 1 To numSets
                For j = LBound(sliceSizes) To UBound(sliceSizes)
                    If sliceSizes(j) <= numTrx Then
                        shuffledPairs = PairAndShuffle(datesArr, amtsArr)
                        
                        wsOut.Cells(outputRow, 1).Value = wsSrc.Cells(i, 1).Value
                        wsOut.Cells(outputRow, 2).Value = wsSrc.Cells(i, 2).Value
                        wsOut.Cells(outputRow, 3).Value = Join(SliceArray(shuffledPairs, sliceSizes(j), 0), ", ")
                        wsOut.Cells(outputRow, 4).Value = Join(SliceArray(shuffledPairs, sliceSizes(j), 1), ", ")
                        wsOut.Cells(outputRow, 5).Value = sliceSizes(j)
                        wsOut.Cells(outputRow, 6).Value = setNum
                        outputRow = outputRow + 1
                    End If
                Next j
            Next setNum
        End If
    Next i
End Sub

' PairAndShuffle and SliceArray functions remain the same as before


' Pairs dates and amounts, then shuffles the pairs randomly
Function PairAndShuffle(datesArr As Variant, amtsArr As Variant) As Variant
    Dim n As Long, i As Long
    n = UBound(datesArr)
    Dim tempPairs() As Variant
    ReDim tempPairs(0 To n, 0 To 1)

    For i = 0 To n
        tempPairs(i, 0) = Trim(datesArr(i))
        tempPairs(i, 1) = Trim(amtsArr(i))
    Next i

    Dim j As Long, tmp0 As Variant, tmp1 As Variant
    For i = n To 1 Step -1
        j = Int(Rnd() * (i + 1))
        tmp0 = tempPairs(i, 0): tmp1 = tempPairs(i, 1)
        tempPairs(i, 0) = tempPairs(j, 0): tempPairs(i, 1) = tempPairs(j, 1)
        tempPairs(j, 0) = tmp0: tempPairs(j, 1) = tmp1
    Next i

    PairAndShuffle = tempPairs
End Function

' Extracts either dates or amounts from the shuffled pairs array
Function SliceArray(pairs As Variant, ByVal count As Long, colIndex As Integer) As Variant
    Dim result() As String, i As Long
    ReDim result(0 To count - 1)
    For i = 0 To count - 1
        result(i) = pairs(i, colIndex)
    Next i
    SliceArray = result
End Function

Sub CreateTransposedSheets()
    Dim wsSrc As Worksheet
    Dim wsAcct As Worksheet, wsCard As Worksheet, wsDates As Worksheet, wsAmt As Worksheet
    Dim lastRow As Long, i As Long
    Dim headerPrefix As String
    Dim dataRange As Range
    Dim arrAcct As Variant, arrCard As Variant, arrDates As Variant, arrAmt As Variant
    
    Set wsSrc = Worksheets("Expanded") ' Change if your source sheet is named differently
    
    lastRow = wsSrc.Cells(wsSrc.Rows.count, 1).End(xlUp).Row
    If lastRow < 2 Then
        MsgBox "No data found in 'Expanded' sheet.", vbExclamation
        Exit Sub
    End If
    
    ' Read the columns into arrays (excluding header row)
    arrAcct = Application.Transpose(wsSrc.Range(wsSrc.Cells(2, 1), wsSrc.Cells(lastRow, 1)).Value)
    arrCard = Application.Transpose(wsSrc.Range(wsSrc.Cells(2, 2), wsSrc.Cells(lastRow, 2)).Value)
    arrDates = Application.Transpose(wsSrc.Range(wsSrc.Cells(2, 3), wsSrc.Cells(lastRow, 3)).Value)
    arrAmt = Application.Transpose(wsSrc.Range(wsSrc.Cells(2, 4), wsSrc.Cells(lastRow, 4)).Value)
    
    ' Create or clear the 4 sheets
    Set wsAcct = CreateOrClearSheet("acct")
    Set wsCard = CreateOrClearSheet("cardnumber")
    Set wsDates = CreateOrClearSheet("trxdates")
    Set wsAmt = CreateOrClearSheet("trxAmt")
    
    ' Write headers and data for acct sheet
    headerPrefix = "AccountNumber"
    Call WriteHeadersAndData(wsAcct, headerPrefix, arrAcct)
    
    ' Write headers and data for cardnumber sheet
    headerPrefix = "CardNumber"
    Call WriteHeadersAndData(wsCard, headerPrefix, arrCard)
    
    ' Write headers and data for trxdates sheet
    headerPrefix = "TrxDate"
    Call WriteHeadersAndData(wsDates, headerPrefix, arrDates)
    
    ' Write headers and data for trxAmt sheet
    headerPrefix = "TrxAmt"
    Call WriteHeadersAndData(wsAmt, headerPrefix, arrAmt)
    
    MsgBox "Transposed sheets created successfully!", vbInformation
End Sub

' Helper function to create a new sheet or clear existing one
Function CreateOrClearSheet(sheetName As String) As Worksheet
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = Worksheets(sheetName)
    On Error GoTo 0
    If ws Is Nothing Then
        Set ws = Worksheets.Add(After:=Worksheets(Worksheets.count))
        ws.Name = sheetName
    Else
        ws.Cells.Clear
    End If
    Set CreateOrClearSheet = ws
End Function

' Helper to write headers and transposed data starting at row 1, col B (2)
Sub WriteHeadersAndData(ws As Worksheet, headerPrefix As String, dataArr As Variant)
    Dim i As Long, colCount As Long
    
    colCount = UBound(dataArr)
    
    ' Write headers in row 1 starting from column 2 (B)
    For i = 1 To colCount
        ws.Cells(1, i + 1).Value = headerPrefix & i
    Next i
    
    ' Write data in row 2 starting from column 2 (B)
    For i = 1 To colCount
        ws.Cells(2, i + 1).Value = dataArr(i)
    Next i
End Sub




======================

void RemoveHyphensFromDates(const char *originalJson, char **cleanedJson,
                            const char *dateKeys[], int numKeys)
{
    int inputLen = strlen(originalJson);
    char *result = (char *)malloc(inputLen * 2); // allocate enough space
    if (!result) {
        lr_error_message("Memory allocation failed for cleanedJson.");
        *cleanedJson = NULL;
        return;
    }

    // Precompute lengths of keys
    size_t *keyLens = (size_t *)malloc(numKeys * sizeof(size_t));
    if (!keyLens) {
        free(result);
        lr_error_message("Memory allocation failed for key lens.");
        *cleanedJson = NULL;
        return;
    }
    for (int i = 0; i < numKeys; i++) {
        keyLens[i] = strlen(dateKeys[i]);
    }

    const char *src = originalJson;
    char *dst = result;

    while (*src != '\0') {
        if (*src == '"') {
            int matched = 0;

            for (int i = 0; i < numKeys; i++) {
                size_t keyLen = keyLens[i];

                // Check if current position matches: "KeyName": "
                if (strncmp(src + 1, dateKeys[i], keyLen) == 0 &&
                    strncmp(src + 1 + keyLen, "\": \"", 4) == 0) 
                {
                    // Copy key + '": "'
                    strncpy(dst, src, keyLen + 5);
                    dst += keyLen + 5;
                    src += keyLen + 5;

                    // Copy value skipping hyphens
                    while (*src && *src != '"') {
                        if (*src != '-') {
                            *dst++ = *src;
                        }
                        src++;
                    }

                    // Copy closing quote
                    if (*src == '"') {
                        *dst++ = *src++;
                    }

                    matched = 1;
                    break;
                }
            }

            if (!matched) {
                *dst++ = *src++;
            }
        } else {
            *dst++ = *src++;
        }
    }

    *dst = '\0';
    *cleanedJson = result;
    free(keyLens);
}


===============


void RemoveHyphensFromDates(const char *originalJson, char **cleanedJson,
                            const char *dateKeys[], int numKeys)
{
    int inputLen = strlen(originalJson);
    char *result = (char *)malloc(inputLen * 2); // Allocate extra space
    if (!result) {
        lr_error_message("Memory allocation failed for cleanedJson.");
        *cleanedJson = NULL;
        return;
    }

    const char *src = originalJson;
    char *dst = result;

    while (*src != '\0') {
        int matched = 0;

        for (int i = 0; i < numKeys; i++) {
            size_t keyLen = strlen(dateKeys[i]);

            if (strncmp(src, "\"", 1) == 0 &&
                strncmp(src + 1, dateKeys[i], keyLen) == 0 &&
                strncmp(src + 1 + keyLen, "\": \"", 4) == 0) {

                // Match found: copy key and formatting
                strncpy(dst, src, keyLen + 5); // includes quote, key, ":
                dst += keyLen + 5;
                src += keyLen + 5;

                // Copy value, skipping hyphens
                while (*src && *src != '"') {
                    if (*src != '-') {
                        *dst++ = *src;
                    }
                    src++;
                }

                // Copy closing quote
                if (*src == '"') {
                    *dst++ = *src++;
                }

                matched = 1;
                break;
            }
        }

        if (!matched) {
            *dst++ = *src++;
        }
    }

    *dst = '\0';
    *cleanedJson = result;
}

/**
 * Removes hyphens from specific date fields in a JSON string.
 * Input: originalJson (input JSON string)
 * Output: cleanedJson (will contain cleaned result)
 * Parameters:
 *   dateKeys[]: array of date field names to target
 *   numKeys: number of keys in the array
 */
void RemoveHyphensFromDates(const char *originalJson, char **cleanedJson,
                            const char *dateKeys[], int numKeys)
{
    int inputLen = strlen(originalJson);
    char *result = (char *)malloc(inputLen * 2); // double size buffer just in case
    if (!result) {
        lr_error_message("Memory allocation failed for cleanedJson.");
        *cleanedJson = NULL;
        return;
    }

    const char *src = originalJson;
    char *dst = result;

    int inQuotes = 0;
    int matchingKey = 0;

    while (*src != '\0') {
        // Toggle quote flag
        if (*src == '"') {
            inQuotes = !inQuotes;
            *dst++ = *src++;
            continue;
        }

        if (inQuotes) {
            matchingKey = 0;
            for (int i = 0; i < numKeys; i++) {
                size_t keyLen = strlen(dateKeys[i]);
                if (strncmp(src, dateKeys[i], keyLen) == 0 && src[keyLen] == '"') {
                    matchingKey = 1;
                    strncpy(dst, src, keyLen);
                    dst += keyLen;
                    src += keyLen;
                    *dst++ = *src++; // trailing quote
                    break;
                }
            }

            if (matchingKey) {
                // Move to next quote (start of value)
                while (*src && *src != '"') {
                    *dst++ = *src++;
                }

                if (*src == '"') {
                    *dst++ = *src++; // opening quote
                    // Copy value, skip hyphens
                    while (*src && *src != '"') {
                        if (*src != '-') {
                            *dst++ = *src;
                        }
                        src++;
                    }

                    if (*src == '"') {
                        *dst++ = *src++; // closing quote
                    }
                }
                continue;
            }
        }

        *dst++ = *src++;
    }

    *dst = '\0';
    *cleanedJson = result;
}


--
Action()
{
    const char *responseJson = lr_eval_string("{responseParam}"); // Replace with your param
    const char *dateKeys[] = {
        "ReceivedMerchantDate",
        "MerchantShipDate",
        "CardHolderDate",
        "OpenDate"
    };

    char *cleanedJson = NULL;

    RemoveHyphensFromDates(responseJson, &cleanedJson,
        dateKeys, sizeof(dateKeys) / sizeof(dateKeys[0]));

    if (cleanedJson != NULL) {
        lr_output_message("Cleaned JSON: %.1000s", cleanedJson);

        // Optional: save as parameter
        lr_save_string(cleanedJson, "CleanedJson");

        // Use in web_custom_request if needed
        web_custom_request("SubmitCleaned",
            "URL=http://example.com/endpoint",
            "Method=POST",
            "Body={CleanedJson}",
            LAST);

        free(cleanedJson); // Always free
    }

    return 0;
}

--



Action()
{
    char rawJson[5000];
    char cleanedJson[5000];

    const char *dateFields[] = {
        "ReceivedMerchantDate",
        "MerchantShipDate",
        "CardHolderDate",
        "OpenDate"
    };

    strcpy(rawJson,
        "{"
        "\"AcctDetails\": {"
        "  \"AcctBalance\": \"100\","
        "  \"TrxList\": ["
        "    {"
        "      \"ARN\": \"2001\","
        "      \"OpenDate\": \"2024-01-01\","
        "      \"DisputeIntent\": {"
        "        \"ReceivedMerchantDate\": \"2025-12-10\","
        "        \"MerchantShipDate\": \"2025-12-10\""
        "      }"
        "    },"
        "    {"
        "      \"ARN\": \"2002\","
        "      \"OpenDate\": \"2020-10-01\","
        "      \"DisputeIntent\": {"
        "        \"ReceivedMerchantDate\": \"2025-12-10\","
        "        \"MerchantShipDate\": \"2025-12-10\""
        "      }"
        "    }"
        "  ]"
        "}"
        "}"
    );

    lr_output_message("Before:\n%s", rawJson);

    RemoveHyphensFromDateFields(rawJson, cleanedJson,
        dateFields, sizeof(dateFields)/sizeof(dateFields[0]));

    lr_output_message("After:\n%s", cleanedJson);

    // Optionally use cleaned JSON in web request
    web_custom_request("SubmitRequest",
        "URL=http://example.com/api",
        "Method=POST",
        "Body={cleanedJson}",
        LAST);

    return 0;
}


================
Action()
{
    // Assume responseBodyParam contains your JSON (saved from web request)
    const char *responseJson = lr_eval_string("{responseBodyParam}");
    int len = strlen(responseJson);

    // Dynamically allocate buffers
    char *rawJson = (char *)malloc(len + 1);
    char *cleanedJson = (char *)malloc(len + 1);

    if (!rawJson || !cleanedJson) {
        lr_error_message("Memory allocation failed.");
        return -1;
    }

    strcpy(rawJson, responseJson);

    const char *dateFields[] = {
        "ReceivedMerchantDate",
        "MerchantShipDate",
        "CardHolderDate",
        "OpenDate"
    };

    RemoveHyphensFromDateFields(rawJson, cleanedJson,
        dateFields, sizeof(dateFields) / sizeof(dateFields[0]));

    lr_output_message("Cleaned JSON:\n%.1000s", cleanedJson); // Limit print

    // Save to parameter if needed
    lr_save_string(cleanedJson, "CleanedJson");

    // Use cleaned JSON in request
    web_custom_request("PostCleanedJson",
        "URL=http://example.com/api",
        "Method=POST",
        "Body={CleanedJson}",
        LAST);

    free(rawJson);
    free(cleanedJson);

    return 0;
}


=================







void CleanDisputeIntentDates(const char *inputJson, char *outputJson,
                             const char *dateFields[], int numFields) {
    const char *src = inputJson;
    char *dst = outputJson;

    int inQuotes = 0;
    int inDisputeIntent = 0;
    int matchDateField = 0;

    while (*src != '\0') {
        if (*src == '"') {
            inQuotes = !inQuotes;
            *dst++ = *src++;
            continue;
        }

        if (!inQuotes && strncmp(src, "DisputeIntent", 13) == 0) {
            inDisputeIntent = 1;
        }

        if (inDisputeIntent && inQuotes) {
            for (int i = 0; i < numFields; i++) {
                if (strncmp(src, dateFields[i], strlen(dateFields[i])) == 0) {
                    matchDateField = 1;
                    break;
                }
            }
        }

        if (inDisputeIntent && matchDateField && *src == '-') {
            src++;  // Skip hyphen (do not add to output)
        } else {
            *dst++ = *src;

            if (inDisputeIntent && *src == '}') {
                inDisputeIntent = 0;
                matchDateField = 0;
            }

            if (*src == ',' || *src == '}') {
                matchDateField = 0;
            }

            src++;
        }
    }

    *dst = '\0'; // End the cleaned string
}


===========


// Function that removes hyphens from specific date fields inside DisputeIntent blocks
void CleanDisputeIntentDates(const char *inputJson, char *outputJson,
                             const char *dateFields[], int numFields) {
    const char *src = inputJson;    // Pointer to read input JSON
    char *dst = outputJson;         // Pointer to write modified JSON

    int inQuotes = 0;               // Flag: are we inside a string (inside quotes)?
    int inDisputeIntent = 0;        // Flag: are we inside a DisputeIntent block?
    int matchDateField = 0;         // Flag: did we match a known date field?

    // Loop through every character in input JSON
    while (*src != '\0') {
        // Toggle inQuotes when we see a quote (")
        if (*src == '"') {
            inQuotes = !inQuotes;
            *dst++ = *src++;
            continue;
        }

        // If not inside quotes, check if we're entering a DisputeIntent block
        if (!inQuotes && strncmp(src, "DisputeIntent", 13) == 0) {
            inDisputeIntent = 1; // Mark that we're inside DisputeIntent
        }

        // If we're inside DisputeIntent and inside a quoted key
        if (inDisputeIntent && inQuotes) {
            // Check if this quoted field matches any known date key
            for (int i = 0; i < numFields; i++) {
                if (strncmp(src, dateFields[i], strlen(dateFields[i])) == 0) {
                    matchDateField = 1; // Found a date field we're targeting
                    break;
                }
            }
        }

        // If we're in DisputeIntent, in a date field, and the char is a hyphen
        if (inDisputeIntent && matchDateField && *src == '-') {
            *dst++ = ' ';  // Replace hyphen with space
            src++;         // Skip original hyphen
        } else {
            *dst++ = *src; // Copy current character to output

            // End of DisputeIntent block â€” reset flag
            if (inDisputeIntent && *src == '}') {
                inDisputeIntent = 0;
                matchDateField = 0;
            }

            // Reset date field match at comma or close of block
            if (*src == ',' || *src == '}') {
                matchDateField = 0;
            }

            src++; // Move to next character
        }
    }

    *dst = '\0'; // Null-terminate the final output string
}



-------


Action()
{
    char rawJson[5000];     // Original JSON input
    char cleanedJson[5000]; // Buffer for modified JSON output

    // List of date field names to clean (remove hyphens from)
    const char *dateFields[] = {
        "ReceivedMerchantDate",
        "MerchantShipDate"
    };

    // Sample JSON (as from your example)
    strcpy(rawJson,
        "{"
        "\"AcctDetails\": {"
        "  \"AcctBalance\": \"100\","
        "  \"TrxList\": ["
        "    {"
        "      \"ARN\": \"2001\","
        "      \"OpenDate\": \"2024-01-01\","
        "      \"DisputeIntent\": {"
        "        \"ReceivedMerchantDate\": \"2025-12-10\","
        "        \"MerchantShipDate\": \"2025-12-10\""
        "      }"
        "    },"
        "    {"
        "      \"ARN\": \"2002\","
        "      \"OpenDate\": \"2020-10-01\","
        "      \"DisputeIntent\": {"
        "        \"ReceivedMerchantDate\": \"2025-12-10\","
        "        \"MerchantShipDate\": \"2025-12-10\""
        "      }"
        "    }"
        "  ]"
        "}"
        "}"
    );

    // Show the original
    lr_output_message("Original JSON:\n%s", rawJson);

    // Call the cleaning function
    CleanDisputeIntentDates(rawJson, cleanedJson, dateFields, sizeof(dateFields)/sizeof(dateFields[0]));

    // Output the cleaned version
    lr_output_message("Cleaned JSON:\n%s", cleanedJson);

    // Use the cleaned JSON in next request
    web_custom_request("SubmitCleanedJson",
        "URL=http://example.com/api/next",
        "Method=POST",
        "Body={cleanedJson}",
        LAST);

    return 0;
}





// Function to clean hyphens from specific date fields in a JSON string
void CleanDatesInJson(const char *inputJson, char *outputJson, const char *dateKeys[], int numKeys) {
    const char *src = inputJson;
    char *dst = outputJson;
    int inQuotes = 0;
    int foundDateKey = 0;

    while (*src != '\0') {
        // Detect matching date key
        for (int i = 0; i < numKeys; i++) {
            size_t keyLen = strlen(dateKeys[i]);

            if (!inQuotes && strncmp(src, dateKeys[i], keyLen) == 0 && src[keyLen] == '"') {
                foundDateKey = 1;
                break;
            }
        }

        if (*src == '"') {
            inQuotes = !inQuotes;
            *dst++ = *src++;
        }
        else if (inQuotes && foundDateKey && *src == '-') {
            *dst++ = ' ';
            src++;
        }
        else {
            *dst++ = *src++;

            if (*(src - 1) == ',' || *(src - 1) == '}') {
                foundDateKey = 0; // Reset flag at end of value
            }
        }
    }

    *dst = '\0'; // Null-terminate the output string
}


======================

char rawJson[10000];
char cleanedJson[10000];

const char *dateKeys[] = {
    "ReceivedMerchantDate",
    "CardHolderDate",
    "MerchantShipDate"
};

// Capture JSON response
web_reg_save_param("FullJson",
    "LB=",
    "RB=",
    "Search=Body",
    LAST);

web_custom_request("GetData",
    "URL=http://example.com/api/get",
    "Method=GET",
    LAST);

// Clean dates
strcpy(rawJson, lr_eval_string("{FullJson}"));
CleanDatesInJson(rawJson, cleanedJson, dateKeys, sizeof(dateKeys)/sizeof(dateKeys[0]));

// Use cleaned JSON
web_custom_request("PostData",
    "URL=http://example.com/api/post",
    "Method=POST",
    "BodyBinary={cleanedJson}",
    LAST);

=============================


#ifndef CLEAN_JSON_H
#define CLEAN_JSON_H

#include <string.h>
#include <stdio.h>

// Replaces hyphens with spaces in values of specified date keys in a JSON string
void CleanDatesInJson(const char *inputJson, char *outputJson, const char *dateKeys[], int numKeys) {
    const char *src = inputJson;
    char *dst = outputJson;
    int inQuotes = 0;
    int foundDateKey = 0;

    while (*src != '\0') {
        // Detect matching date key
        for (int i = 0; i < numKeys; i++) {
            size_t keyLen = strlen(dateKeys[i]);

            // Only check for keys outside of quotes to avoid false positives
            if (!inQuotes && strncmp(src, dateKeys[i], keyLen) == 0 && src[keyLen] == '"') {
                foundDateKey = 1;
                break;
            }
        }

        // Toggle quote tracking
        if (*src == '"') {
            inQuotes = !inQuotes;
            *dst++ = *src++;
        }
        // Replace hyphen inside quoted value after key match
        else if (inQuotes && foundDateKey && *src == '-') {
            *dst++ = ' ';
            src++;
        }
        else {
            *dst++ = *src++;

            // If value segment ends, reset the date key flag
            if (*(src - 1) == ',' || *(src - 1) == '}') {
                foundDateKey = 0;
            }
        }
    }

    *dst = '\0'; // Null-terminate output
}

#endif // CLEAN_JSON_H



char rawJson[10000];
char cleanedJson[10000];

// Step 1: Save full JSON response
web_reg_save_param("FullJson",
    "LB=",
    "RB=",
    "Search=Body",
    LAST);

web_custom_request("GetTransactions",
    "URL=http://example.com/api/transactions",
    "Method=GET",
    LAST);

// Step 2: Evaluate and clean JSON
strcpy(rawJson, lr_eval_string("{FullJson}"));

// Define keys to clean
const char *dateKeys[] = {
    "ReceivedMerchantDate",
    "CardHolderDate",
    "MerchantShipDate"
};

// Call reusable function
CleanDatesInJson(rawJson, cleanedJson, dateKeys, sizeof(dateKeys)/sizeof(dateKeys[0]));

// Optional: Log cleaned output
lr_output_message("Cleaned JSON:\n%s", cleanedJson);

// Step 3: Use cleaned JSON as body in next request
web_custom_request("PostCleanedJson",
    "URL=http://example.com/api/nextstep",
    "Method=POST",
    "BodyBinary={cleanedJson}",
    LAST);



=================





char* str_replace(const char* original, char old_char, char new_char) {
    static char buffer[8192]; // Adjust size as needed
    int i;

    for (i = 0; original[i] != '\0' && i < sizeof(buffer) - 1; i++) {
        buffer[i] = (original[i] == old_char) ? new_char : original[i];
    }

    buffer[i] = '\0';
    return buffer;
}


char* original_json = lr_eval_string("{JsonParam}");
char* modified_json = str_replace(original_json, '-', '_');

lr_save_string(modified_json, "ModifiedJson");
lr_output_message("Modified JSON: %s", lr_eval_string("{ModifiedJson}"));


=================

import requests
import csv
import xml.etree.ElementTree as ET
from datetime import datetime
import sys

NAMESPACES = {
    'soap-env': 'http://schemas.xmlsoap.org/soap/envelope/',
    'ns0': 'http://example.com/ns'
}

API_URL = "https://your-api-endpoint.com/soap"

def parse_date(date_str):
    try:
        return datetime.strptime(date_str, '%Y-%m-%d')
    except:
        return datetime.min

def main(input_csv, output_file):
    # Prepare output file with header
    with open(output_file, 'w', newline='') as out_file:
        writer = csv.writer(out_file)
        writer.writerow(['applicationdesc', 'AcctNumber', 'relationship', 'AssociatedAcct', 'cardsratus',
                         'EffectiveDate', 'ExpiryDate', 'Address', 'Validity'])

    # Read input accounts
    with open(input_csv, newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            acct_num = row['account_number'].strip()

            # Prepare SOAP request
            payload = f"""
            <soap-env:Envelope xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/">
              <soap-env:Body>
                <ns0:GetAccountDetails xmlns:ns0="http://example.com/ns">
                  <ns0:AccountNumber>{acct_num}</ns0:AccountNumber>
                </ns0:GetAccountDetails>
              </soap-env:Body>
            </soap-env:Envelope>
            """

            try:
                response = requests.post(API_URL, data=payload, headers={'Content-Type': 'text/xml'})
                response.raise_for_status()
                root = ET.fromstring(response.text)

                # Group by (AcctNumber, AssociatedAcct)
                unique_debit_cards = {}

                for detail in root.findall('.//ns0:AcctDetail', NAMESPACES):
                    app_desc = detail.findtext('ns0:applicationdesc', '', NAMESPACES)
                    if 'debit' not in app_desc.lower():
                        continue

                    acct_number = detail.findtext('ns0:AcctNumber', '', NAMESPACES)
                    associated_acct = detail.findtext('ns0:ATMCardDetail/ns0:AssociatedAcct', '', NAMESPACES).strip()

                    if not associated_acct:
                        continue

                    expiry_date_str = detail.findtext('ns0:ExpiryDate', '', NAMESPACES)
                    expiry_date = parse_date(expiry_date_str)

                    key = (acct_number, associated_acct)
                    existing = unique_debit_cards.get(key)

                    if not existing or expiry_date > existing['parsed_expiry']:
                        unique_debit_cards[key] = {
                            'applicationdesc': 'DEBIT CARD',
                            'AcctNumber': acct_number,
                            'relationship': detail.findtext('ns0:relationship', '', NAMESPACES),
                            'AssociatedAcct': associated_acct,
                            'cardsratus': detail.findtext('ns0:ATMCardDetail/ns0:cardsratus', '', NAMESPACES),
                            'EffectiveDate': detail.findtext('ns0:EffectiveDate', '', NAMESPACES),
                            'ExpiryDate': expiry_date_str,
                            'Address': detail.findtext('ns0:Address', '', NAMESPACES),
                            'Validity': detail.findtext('ns0:Validity', '', NAMESPACES),
                            'parsed_expiry': expiry_date
                        }

                # Write unique records
                with open(output_file, 'a', newline='') as out_file:
                    writer = csv.writer(out_file)
                    for record in unique_debit_cards.values():
                        del record['parsed_expiry']
                        writer.writerow(record.values())

            except requests.RequestException as e:
                print(f"Error for account {acct_num}: {e}")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python script1.py <input_csv> <output_file>")
        sys.exit(1)

    input_csv = sys.argv[1]
    output_file = sys.argv[2]
    main(input_csv, output_file)



--
import subprocess

def run_script(script, input_file, output_file):
    print(f"Running {script} with input: {input_file}, output: {output_file}")
    subprocess.run(['python', script, input_file, output_file], check=True)

if __name__ == "__main__":
    run_script('script1.py', 'input_accounts.csv', 'output1.csv')
    run_script('script2.py', 'output1.csv', 'output2.csv')
    run_script('script3.py', 'output2.csv', 'output3.csv')
    print("Workflow complete.")


import random
import csv
from collections import defaultdict

def generate_combinations_without_count(
    input_file,
    output_file,
    sample_sizes=[2, 5, 10, 15],
    threshold=10,
    min_date="20250321",
    max_debits_per_account=3,
    samples_per_row=2
):
    # Track debit cards per account to limit output rows
    account_debit_tracker = defaultdict(set)

    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')
        writer.writerow(['account', 'debit', 'dates', 'amounts'])  # header

        for row in reader:
            if len(row) != 5:
                continue  # skip malformed rows

            account, debit, dates_str, amts_str, _ = row
            dates = dates_str.split(',')
            amts = amts_str.split(',')

            if len(dates) != len(amts):
                continue  # skip if mismatch

            # Filter by min_date
            filtered = [(d, a) for d, a in zip(dates, amts) if d > min_date]
            count = len(filtered)

            if count <= 1:
                continue  # skip too small

            # Enforce max debit cards per account
            if debit not in account_debit_tracker[account]:
                if len(account_debit_tracker[account]) >= max_debits_per_account:
                    continue
                account_debit_tracker[account].add(debit)

            if count <= threshold:
                # Output full filtered row as is
                sample_dates = ','.join(d for d, _ in filtered)
                sample_amts = ','.join(a for _, a in filtered)
                writer.writerow([account, debit, sample_dates, sample_amts])
            else:
                # For counts > threshold: generate samples for each bucket <= count
                valid_buckets = [b for b in sorted(sample_sizes) if b <= count]
                for bucket in valid_buckets:
                    for _ in range(samples_per_row):
                        sample = random.sample(filtered, bucket)
                        sample_dates = ','.join(x[0] for x in sample)
                        sample_amts = ','.join(x[1] for x in sample)
                        writer.writerow([account, debit, sample_dates, sample_amts])



generate_combinations_without_count(
    input_file='input.tsv',
    output_file='output.tsv',
    sample_sizes=[2, 5, 10, 15],
    threshold=10,
    min_date="20250321",
    max_debits_per_account=3,
    samples_per_row=2
)



=====================




import random
import csv
from collections import defaultdict

def get_bucket(count, buckets):
    """Return the largest bucket that is <= count."""
    valid = [b for b in sorted(buckets) if b <= count]
    return valid[-1] if valid else None

def generate_combinations_without_count(
    input_file,
    output_file,
    sample_sizes=[2, 5, 10, 15],
    min_date="20250321",
    max_debits_per_account=3,
    samples_per_row=3
):
    # Track unique debit cards used per account
    account_debit_tracker = defaultdict(set)

    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        # Optional header
        writer.writerow(['account', 'debit', 'dates', 'amounts'])

        for row in reader:
            if len(row) != 5:
                continue  # Skip malformed rows

            account, debit, dates_str, amts_str, _ = row  # We ignore 'codes' column

            dates = dates_str.split(',')
            amts = amts_str.split(',')

            if len(dates) != len(amts):
                continue  # Mismatched lengths

            # Filter based on date threshold
            filtered = [(d, a) for d, a in zip(dates, amts) if d > min_date]
            count = len(filtered)

            if count <= 1:
                continue  # Skip if not enough data after filtering

            # Limit how many debit cards are used per account
            if debit not in account_debit_tracker[account]:
                if len(account_debit_tracker[account]) >= max_debits_per_account:
                    continue  # Too many debit cards already used for this account
                account_debit_tracker[account].add(debit)

            bucket = get_bucket(count, sample_sizes)
            if not bucket:
                continue  # No valid bucket size found

            # Generate multiple samples of the same bucket size
            for _ in range(samples_per_row):
                sample = random.sample(filtered, bucket)
                sample_dates = ','.join([x[0] for x in sample])
                sample_amts = ','.join([x[1] for x in sample])
                writer.writerow([account, debit, sample_dates, sample_amts])



generate_combinations_without_count(
    input_file='input.tsv',
    output_file='output.tsv',
    sample_sizes=[2, 5, 10, 15],
    min_date="20250321",
    max_debits_per_account=3,
    samples_per_row=3
)


-------------------------


import csv
import random
from collections import defaultdict

def get_bucket(count, buckets):
    """
    Return the largest bucket from the list that is <= count.
    """
    valid_buckets = [b for b in sorted(buckets) if b <= count]
    return valid_buckets[-1] if valid_buckets else None

def generate_multiple_combinations_per_row(
    input_file,
    output_file,
    buckets=[2, 5, 10, 15],
    samples_per_row=3,
    max_debits_per_account=3  # NEW: Limit number of debit cards per account
):
    # Track how many unique debit cards we've used per account
    account_debit_counter = defaultdict(set)

    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        # Write header
        writer.writerow(['account', 'debit', 'dates', 'amounts'])

        for row in reader:
            if len(row) < 4:
                continue  # Skip malformed rows

            account, debit, dates_str, amts_str = row[:4]
            dates = dates_str.split(',')
            amts = amts_str.split(',')
            count = len(dates)

            # Skip if invalid row
            if count != len(amts) or count <= 1:
                continue

            # Enforce unique debit cards per account
            if debit not in account_debit_counter[account]:
                if len(account_debit_counter[account]) >= max_debits_per_account:
                    continue  # Already reached max debit cards for this account
                account_debit_counter[account].add(debit)

            # Determine sampling bucket
            bucket = get_bucket(count, buckets)
            if bucket is None:
                continue

            # Pair date and amount
            combos = list(zip(dates, amts))

            # Generate N random samples
            for _ in range(samples_per_row):
                sample = random.sample(combos, bucket)
                sample_dates = ','.join([x[0] for x in sample])
                sample_amts = ','.join([x[1] for x in sample])
                writer.writerow([account, debit, sample_dates, sample_amts])
generate_multiple_combinations_per_row(
    input_file='input.tsv',
    output_file='output.tsv',
    buckets=[2, 5, 10, 15],
    samples_per_row=3,
    max_debits_per_account=3  # Only allow up to 3 debit cards per account
)

=====================

#DATE FILTER
import csv
import random
from collections import defaultdict

def get_bucket(count, buckets):
    """Return the largest bucket from the list that is <= count."""
    valid_buckets = [b for b in sorted(buckets) if b <= count]
    return valid_buckets[-1] if valid_buckets else None

def generate_multiple_combinations_per_row(
    input_file,
    output_file,
    buckets=[2, 5, 10, 15],
    samples_per_row=3,
    max_debits_per_account=3,
    min_date_threshold="20250101"  # NEW: Only allow dates greater than this
):
    account_debit_counter = defaultdict(set)

    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        writer.writerow(['account', 'debit', 'dates', 'amounts'])  # header

        for row in reader:
            if len(row) < 4:
                continue  # malformed row

            account, debit, dates_str, amts_str = row[:4]
            dates = dates_str.split(',')
            amts = amts_str.split(',')

            if len(dates) != len(amts):
                continue

            # Filter (date, amount) pairs based on min_date_threshold
            filtered = [(d, a) for d, a in zip(dates, amts) if d > min_date_threshold]

            # Skip rows with less than 2 valid pairs
            if len(filtered) < 2:
                continue

            # Enforce max debits per account
            if debit not in account_debit_counter[account]:
                if len(account_debit_counter[account]) >= max_debits_per_account:
                    continue
                account_debit_counter[account].add(debit)

            bucket = get_bucket(len(filtered), buckets)
            if bucket is None:
                continue

            for _ in range(samples_per_row):
                sample = random.sample(filtered, bucket)
                sample_dates = ','.join([x[0] for x in sample])
                sample_amts = ','.join([x[1] for x in sample])
                writer.writerow([account, debit, sample_dates, sample_amts])


generate_multiple_combinations_per_row(
    input_file='input.tsv',
    output_file='output.tsv',
    buckets=[2, 5, 10, 15],
    samples_per_row=3,
    max_debits_per_account=3,
    min_date_threshold="20250321"  # Only include transactions after this date
)



import csv  # For reading and writing TSV files
import random  # For randomly sampling combinations

def get_bucket(count, buckets):
    """
    Return the largest bucket from the list that is less than or equal to the count.
    E.g., if count = 7 and buckets = [2, 5, 10], it returns 5.
    """
    valid_buckets = [b for b in sorted(buckets) if b <= count]
    return valid_buckets[-1] if valid_buckets else None

def generate_multiple_combinations_per_row(input_file, output_file, buckets=[2, 5, 10, 15], samples_per_row=3):
    # Open input TSV file for reading, and output TSV file for writing
    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')  # Create TSV reader
        writer = csv.writer(outfile, delimiter='\t')  # Create TSV writer

        # Write header row to the output file
        writer.writerow(['account', 'debit', 'dates', 'amounts'])

        # Process each line in the input file
        for row in reader:
            if len(row) < 4:
                continue  # Skip if the row doesn't have enough columns

            # Extract fields from the input row
            account, debit, dates_str, amts_str = row[:4]

            # Split the dates and amounts into lists
            dates = dates_str.split(',')
            amts = amts_str.split(',')

            count = len(dates)  # Determine how many combinations exist

            # Skip row if counts don't match or there's only one combination
            if count != len(amts) or count <= 1:
                continue

            # Determine appropriate bucket size based on available count
            bucket = get_bucket(count, buckets)
            if bucket is None:
                continue  # Skip if no valid bucket found

            # Zip dates and amounts together to form a list of (date, amount) pairs
            combos = list(zip(dates, amts))

            # Generate multiple random samples per row
            for _ in range(samples_per_row):
                sample = random.sample(combos, bucket)  # Pick 'bucket'-sized random sample
                sample_dates = ','.join([x[0] for x in sample])  # Extract dates from the sample
                sample_amts = ','.join([x[1] for x in sample])   # Extract amounts from the sample

                # Write the sampled data to the output file
                writer.writerow([account, debit, sample_dates, sample_amts])



#================

import csv
import random

def get_bucket(count, buckets):
    """
    Return the largest bucket that is <= count.
    """
    valid_buckets = [b for b in sorted(buckets) if b <= count]
    return valid_buckets[-1] if valid_buckets else None

def generate_bucketed_combinations(input_file, output_file, buckets=[2, 5, 10, 15]):
    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        for row in reader:
            if len(row) != 5:
                continue  # Skip malformed rows

            account, debit, dates_str, amts_str, codes_str = row
            dates = dates_str.split(',')
            amts = amts_str.split(',')
            codes = codes_str.split(',')

            count = len(dates)

            # Sanity check
            if count != len(amts) or count != len(codes):
                continue  # Skip inconsistent rows

            if count <= 1:
                continue  # Skip if only one combination

            bucket = get_bucket(count, buckets)
            if bucket is None:
                continue  # No matching bucket

            sample = random.sample(list(zip(dates, amts, codes)), bucket)
            sample_dates = ','.join([x[0] for x in sample])
            sample_amts = ','.join([x[1] for x in sample])
            sample_codes = ','.join([x[2] for x in sample])

            writer.writerow([account, debit, sample_dates, sample_amts, sample_codes])


import random
import csv

def generate_selective_combinations(input_file, output_file, sample_sizes=[2, 5, 10, 15], threshold=10):
    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        for row in reader:
            account, debit, dates_str, amts_str, count_str, codes_str = row
            count = int(count_str)
            dates = dates_str.split(',')
            amts = amts_str.split(',')
            codes = codes_str.split(',')

            combo_list = list(zip(dates, amts, codes))
            total = len(combo_list)

            if count > threshold:
                for size in sample_sizes:
                    if size > total:
                        continue  # skip if not enough data
                    sample = random.sample(combo_list, size)
                    sample_dates = ','.join([x[0] for x in sample])
                    sample_amts = ','.join([x[1] for x in sample])
                    sample_codes = ','.join([x[2] for x in sample])
                    writer.writerow([account, debit, sample_dates, sample_amts, size, sample_codes])
            else:
                # Write original row unchanged
                writer.writerow(row)

# Example usage
generate_selective_combinations('input.tsv', 'output.tsv', sample_sizes=[2, 5, 10, 15], threshold=10)



import random
import csv

def generate_combinations_without_count(input_file, output_file, sample_sizes=[2, 5, 10, 15], threshold=10):
    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        for row in reader:
            if len(row) != 5:
                continue  # Skip malformed rows

            account, debit, dates_str, amts_str, codes_str = row
            dates = dates_str.split(',')
            amts = amts_str.split(',')
            codes = codes_str.split(',')

            combo_list = list(zip(dates, amts, codes))
            total = len(combo_list)

            if total > threshold:
                for size in sample_sizes:
                    if size > total:
                        continue
                    sample = random.sample(combo_list, size)
                    sample_dates = ','.join([x[0] for x in sample])
                    sample_amts = ','.join([x[1] for x in sample])
                    sample_codes = ','.join([x[2] for x in sample])
                    writer.writerow([account, debit, sample_dates, sample_amts, sample_codes])
            else:
                # Write the original row as-is
                writer.writerow(row)

# Example usage
generate_combinations_without_count('input.tsv', 'output.tsv', sample_sizes=[2, 5, 10, 15], threshold=10)


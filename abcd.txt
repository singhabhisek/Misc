import random
import csv
from collections import defaultdict

def generate_combinations_without_count(
    input_file,
    output_file,
    sample_sizes=[2, 5, 10, 15],
    threshold=10,
    min_date="20250321",
    max_debits_per_account=3,
    samples_per_row=2
):
    # Track debit cards per account to limit output rows
    account_debit_tracker = defaultdict(set)

    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')
        writer.writerow(['account', 'debit', 'dates', 'amounts'])  # header

        for row in reader:
            if len(row) != 5:
                continue  # skip malformed rows

            account, debit, dates_str, amts_str, _ = row
            dates = dates_str.split(',')
            amts = amts_str.split(',')

            if len(dates) != len(amts):
                continue  # skip if mismatch

            # Filter by min_date
            filtered = [(d, a) for d, a in zip(dates, amts) if d > min_date]
            count = len(filtered)

            if count <= 1:
                continue  # skip too small

            # Enforce max debit cards per account
            if debit not in account_debit_tracker[account]:
                if len(account_debit_tracker[account]) >= max_debits_per_account:
                    continue
                account_debit_tracker[account].add(debit)

            if count <= threshold:
                # Output full filtered row as is
                sample_dates = ','.join(d for d, _ in filtered)
                sample_amts = ','.join(a for _, a in filtered)
                writer.writerow([account, debit, sample_dates, sample_amts])
            else:
                # For counts > threshold: generate samples for each bucket <= count
                valid_buckets = [b for b in sorted(sample_sizes) if b <= count]
                for bucket in valid_buckets:
                    for _ in range(samples_per_row):
                        sample = random.sample(filtered, bucket)
                        sample_dates = ','.join(x[0] for x in sample)
                        sample_amts = ','.join(x[1] for x in sample)
                        writer.writerow([account, debit, sample_dates, sample_amts])



generate_combinations_without_count(
    input_file='input.tsv',
    output_file='output.tsv',
    sample_sizes=[2, 5, 10, 15],
    threshold=10,
    min_date="20250321",
    max_debits_per_account=3,
    samples_per_row=2
)



=====================




import random
import csv
from collections import defaultdict

def get_bucket(count, buckets):
    """Return the largest bucket that is <= count."""
    valid = [b for b in sorted(buckets) if b <= count]
    return valid[-1] if valid else None

def generate_combinations_without_count(
    input_file,
    output_file,
    sample_sizes=[2, 5, 10, 15],
    min_date="20250321",
    max_debits_per_account=3,
    samples_per_row=3
):
    # Track unique debit cards used per account
    account_debit_tracker = defaultdict(set)

    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        # Optional header
        writer.writerow(['account', 'debit', 'dates', 'amounts'])

        for row in reader:
            if len(row) != 5:
                continue  # Skip malformed rows

            account, debit, dates_str, amts_str, _ = row  # We ignore 'codes' column

            dates = dates_str.split(',')
            amts = amts_str.split(',')

            if len(dates) != len(amts):
                continue  # Mismatched lengths

            # Filter based on date threshold
            filtered = [(d, a) for d, a in zip(dates, amts) if d > min_date]
            count = len(filtered)

            if count <= 1:
                continue  # Skip if not enough data after filtering

            # Limit how many debit cards are used per account
            if debit not in account_debit_tracker[account]:
                if len(account_debit_tracker[account]) >= max_debits_per_account:
                    continue  # Too many debit cards already used for this account
                account_debit_tracker[account].add(debit)

            bucket = get_bucket(count, sample_sizes)
            if not bucket:
                continue  # No valid bucket size found

            # Generate multiple samples of the same bucket size
            for _ in range(samples_per_row):
                sample = random.sample(filtered, bucket)
                sample_dates = ','.join([x[0] for x in sample])
                sample_amts = ','.join([x[1] for x in sample])
                writer.writerow([account, debit, sample_dates, sample_amts])



generate_combinations_without_count(
    input_file='input.tsv',
    output_file='output.tsv',
    sample_sizes=[2, 5, 10, 15],
    min_date="20250321",
    max_debits_per_account=3,
    samples_per_row=3
)


-------------------------


import csv
import random
from collections import defaultdict

def get_bucket(count, buckets):
    """
    Return the largest bucket from the list that is <= count.
    """
    valid_buckets = [b for b in sorted(buckets) if b <= count]
    return valid_buckets[-1] if valid_buckets else None

def generate_multiple_combinations_per_row(
    input_file,
    output_file,
    buckets=[2, 5, 10, 15],
    samples_per_row=3,
    max_debits_per_account=3  # NEW: Limit number of debit cards per account
):
    # Track how many unique debit cards we've used per account
    account_debit_counter = defaultdict(set)

    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        # Write header
        writer.writerow(['account', 'debit', 'dates', 'amounts'])

        for row in reader:
            if len(row) < 4:
                continue  # Skip malformed rows

            account, debit, dates_str, amts_str = row[:4]
            dates = dates_str.split(',')
            amts = amts_str.split(',')
            count = len(dates)

            # Skip if invalid row
            if count != len(amts) or count <= 1:
                continue

            # Enforce unique debit cards per account
            if debit not in account_debit_counter[account]:
                if len(account_debit_counter[account]) >= max_debits_per_account:
                    continue  # Already reached max debit cards for this account
                account_debit_counter[account].add(debit)

            # Determine sampling bucket
            bucket = get_bucket(count, buckets)
            if bucket is None:
                continue

            # Pair date and amount
            combos = list(zip(dates, amts))

            # Generate N random samples
            for _ in range(samples_per_row):
                sample = random.sample(combos, bucket)
                sample_dates = ','.join([x[0] for x in sample])
                sample_amts = ','.join([x[1] for x in sample])
                writer.writerow([account, debit, sample_dates, sample_amts])
generate_multiple_combinations_per_row(
    input_file='input.tsv',
    output_file='output.tsv',
    buckets=[2, 5, 10, 15],
    samples_per_row=3,
    max_debits_per_account=3  # Only allow up to 3 debit cards per account
)

=====================

#DATE FILTER
import csv
import random
from collections import defaultdict

def get_bucket(count, buckets):
    """Return the largest bucket from the list that is <= count."""
    valid_buckets = [b for b in sorted(buckets) if b <= count]
    return valid_buckets[-1] if valid_buckets else None

def generate_multiple_combinations_per_row(
    input_file,
    output_file,
    buckets=[2, 5, 10, 15],
    samples_per_row=3,
    max_debits_per_account=3,
    min_date_threshold="20250101"  # NEW: Only allow dates greater than this
):
    account_debit_counter = defaultdict(set)

    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        writer.writerow(['account', 'debit', 'dates', 'amounts'])  # header

        for row in reader:
            if len(row) < 4:
                continue  # malformed row

            account, debit, dates_str, amts_str = row[:4]
            dates = dates_str.split(',')
            amts = amts_str.split(',')

            if len(dates) != len(amts):
                continue

            # Filter (date, amount) pairs based on min_date_threshold
            filtered = [(d, a) for d, a in zip(dates, amts) if d > min_date_threshold]

            # Skip rows with less than 2 valid pairs
            if len(filtered) < 2:
                continue

            # Enforce max debits per account
            if debit not in account_debit_counter[account]:
                if len(account_debit_counter[account]) >= max_debits_per_account:
                    continue
                account_debit_counter[account].add(debit)

            bucket = get_bucket(len(filtered), buckets)
            if bucket is None:
                continue

            for _ in range(samples_per_row):
                sample = random.sample(filtered, bucket)
                sample_dates = ','.join([x[0] for x in sample])
                sample_amts = ','.join([x[1] for x in sample])
                writer.writerow([account, debit, sample_dates, sample_amts])


generate_multiple_combinations_per_row(
    input_file='input.tsv',
    output_file='output.tsv',
    buckets=[2, 5, 10, 15],
    samples_per_row=3,
    max_debits_per_account=3,
    min_date_threshold="20250321"  # Only include transactions after this date
)



import csv  # For reading and writing TSV files
import random  # For randomly sampling combinations

def get_bucket(count, buckets):
    """
    Return the largest bucket from the list that is less than or equal to the count.
    E.g., if count = 7 and buckets = [2, 5, 10], it returns 5.
    """
    valid_buckets = [b for b in sorted(buckets) if b <= count]
    return valid_buckets[-1] if valid_buckets else None

def generate_multiple_combinations_per_row(input_file, output_file, buckets=[2, 5, 10, 15], samples_per_row=3):
    # Open input TSV file for reading, and output TSV file for writing
    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')  # Create TSV reader
        writer = csv.writer(outfile, delimiter='\t')  # Create TSV writer

        # Write header row to the output file
        writer.writerow(['account', 'debit', 'dates', 'amounts'])

        # Process each line in the input file
        for row in reader:
            if len(row) < 4:
                continue  # Skip if the row doesn't have enough columns

            # Extract fields from the input row
            account, debit, dates_str, amts_str = row[:4]

            # Split the dates and amounts into lists
            dates = dates_str.split(',')
            amts = amts_str.split(',')

            count = len(dates)  # Determine how many combinations exist

            # Skip row if counts don't match or there's only one combination
            if count != len(amts) or count <= 1:
                continue

            # Determine appropriate bucket size based on available count
            bucket = get_bucket(count, buckets)
            if bucket is None:
                continue  # Skip if no valid bucket found

            # Zip dates and amounts together to form a list of (date, amount) pairs
            combos = list(zip(dates, amts))

            # Generate multiple random samples per row
            for _ in range(samples_per_row):
                sample = random.sample(combos, bucket)  # Pick 'bucket'-sized random sample
                sample_dates = ','.join([x[0] for x in sample])  # Extract dates from the sample
                sample_amts = ','.join([x[1] for x in sample])   # Extract amounts from the sample

                # Write the sampled data to the output file
                writer.writerow([account, debit, sample_dates, sample_amts])



#================

import csv
import random

def get_bucket(count, buckets):
    """
    Return the largest bucket that is <= count.
    """
    valid_buckets = [b for b in sorted(buckets) if b <= count]
    return valid_buckets[-1] if valid_buckets else None

def generate_bucketed_combinations(input_file, output_file, buckets=[2, 5, 10, 15]):
    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        for row in reader:
            if len(row) != 5:
                continue  # Skip malformed rows

            account, debit, dates_str, amts_str, codes_str = row
            dates = dates_str.split(',')
            amts = amts_str.split(',')
            codes = codes_str.split(',')

            count = len(dates)

            # Sanity check
            if count != len(amts) or count != len(codes):
                continue  # Skip inconsistent rows

            if count <= 1:
                continue  # Skip if only one combination

            bucket = get_bucket(count, buckets)
            if bucket is None:
                continue  # No matching bucket

            sample = random.sample(list(zip(dates, amts, codes)), bucket)
            sample_dates = ','.join([x[0] for x in sample])
            sample_amts = ','.join([x[1] for x in sample])
            sample_codes = ','.join([x[2] for x in sample])

            writer.writerow([account, debit, sample_dates, sample_amts, sample_codes])


import random
import csv

def generate_selective_combinations(input_file, output_file, sample_sizes=[2, 5, 10, 15], threshold=10):
    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        for row in reader:
            account, debit, dates_str, amts_str, count_str, codes_str = row
            count = int(count_str)
            dates = dates_str.split(',')
            amts = amts_str.split(',')
            codes = codes_str.split(',')

            combo_list = list(zip(dates, amts, codes))
            total = len(combo_list)

            if count > threshold:
                for size in sample_sizes:
                    if size > total:
                        continue  # skip if not enough data
                    sample = random.sample(combo_list, size)
                    sample_dates = ','.join([x[0] for x in sample])
                    sample_amts = ','.join([x[1] for x in sample])
                    sample_codes = ','.join([x[2] for x in sample])
                    writer.writerow([account, debit, sample_dates, sample_amts, size, sample_codes])
            else:
                # Write original row unchanged
                writer.writerow(row)

# Example usage
generate_selective_combinations('input.tsv', 'output.tsv', sample_sizes=[2, 5, 10, 15], threshold=10)



import random
import csv

def generate_combinations_without_count(input_file, output_file, sample_sizes=[2, 5, 10, 15], threshold=10):
    with open(input_file, 'r') as infile, open(output_file, 'w', newline='') as outfile:
        reader = csv.reader(infile, delimiter='\t')
        writer = csv.writer(outfile, delimiter='\t')

        for row in reader:
            if len(row) != 5:
                continue  # Skip malformed rows

            account, debit, dates_str, amts_str, codes_str = row
            dates = dates_str.split(',')
            amts = amts_str.split(',')
            codes = codes_str.split(',')

            combo_list = list(zip(dates, amts, codes))
            total = len(combo_list)

            if total > threshold:
                for size in sample_sizes:
                    if size > total:
                        continue
                    sample = random.sample(combo_list, size)
                    sample_dates = ','.join([x[0] for x in sample])
                    sample_amts = ','.join([x[1] for x in sample])
                    sample_codes = ','.join([x[2] for x in sample])
                    writer.writerow([account, debit, sample_dates, sample_amts, sample_codes])
            else:
                # Write the original row as-is
                writer.writerow(row)

# Example usage
generate_combinations_without_count('input.tsv', 'output.tsv', sample_sizes=[2, 5, 10, 15], threshold=10)

